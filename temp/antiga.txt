--	inserir pedidos de produtos na associativa [Reserva_Bar]
CREATE PROCEDURE [scReserva].[proc_insert_ReservaBar]
	@id_reserva INT,
	@id_produto TINYINT,
	@num_quantidade TINYINT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT; -- verifica se a reserva já consumiu o produto antes, selecionando o número de pedidos registrados
	DECLARE @select_reserva INT; -- verifica se a reserva existe, selecionando o status atual da reserva
	DECLARE @select_produto TINYINT; -- verifica se o produto existe

	SET @select_row = (SELECT num_pedidos FROM [scReserva].[Reserva_Bar] 
						WHERE id_reserva = @id_reserva AND id_produto = @id_produto);

	SET @select_reserva = (SELECT status FROM [scReserva].[Reserva]
							WHERE id_reserva = @id_reserva);

	SET @select_produto = (SELECT id_produto FROM [scEstalagem].[Cardapio_Bar]
							WHERE id_produto = @id_produto);

	IF (@select_reserva = 0)
		-- em caso da reserva já estar encerrada
		RAISERROR('A reserva já foi encerrada.', 16, 1)
	ELSE IF (@select_reserva IS NULL)
		-- em caso de um id_reserva não existente
		RAISERROR('Reserva inexistente.', 16, 1);
	ELSE IF (@select_produto IS NULL)
		-- em caso de um id_produto não existente
		RAISERROR('Produto não consta no banco.', 16, 1);
	ELSE IF (@num_quantidade < 1)
		-- impede a inserção de´valores negativos e nulos
		RAISERROR('Não é possível inserir valores nulos ou negativos.', 16, 1);
	ELSE IF (@select_row IS NULL)
		-- realização de um novo insert
		INSERT INTO [scReserva].[Reserva_Bar] (id_reserva, id_produto, num_pedidos)
		VALUES 	(@id_reserva, @id_produto, @num_quantidade);
	ELSE
		-- realização da atualização do número de pedidos
		UPDATE [scReserva].[Reserva_Bar]
		SET num_pedidos = (@select_row + @num_quantidade)
		WHERE id_reserva = @id_reserva AND id_produto = @id_produto
END
GO


--	inserir pedidos de servicos na associativa [scReserva].[Reserva_Servico]
CREATE PROCEDURE [scReserva].[proc_insert_ReservaServico]
	@id_reserva INT,
	@id_servico TINYINT,
	@num_quantidade TINYINT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT; -- verifica se a reserva já solicitou o serviço antes, selecionando o número de solicitações registradas
	DECLARE @select_reserva INT; -- verifica se a reserva existe, selecionando o status atual da reserva
	DECLARE @select_servico TINYINT; -- verifica se o serviço é oferecido

	SET @select_row = (SELECT num_solicitacao FROM [scReserva].[Reserva_Servico] 
						WHERE id_reserva = @id_reserva AND id_servico = @id_servico);

	SET @select_reserva = (SELECT status FROM [scReserva].[Reserva]
							WHERE id_reserva = @id_reserva);

	SET @select_servico = (SELECT id_servico FROM [scEstalagem].[Servico]
							WHERE id_servico = @id_servico);

	IF (@select_reserva = 0)
		-- em caso da reserva já estar encerrada
		RAISERROR('A reserva já foi encerrada.', 16, 1)
	ELSE IF (@select_reserva IS NULL)
		-- em caso de um id_reserva não existente
		RAISERROR('Reserva inexistente.', 16, 1);
	ELSE IF (@select_servico IS NULL)
		-- em caso de um id_servico não existente
		RAISERROR('Serviço não consta no banco.', 16, 1);
	ELSE IF (@num_quantidade < 1)
		-- impede a inserção de´valores negativos e nulos
		RAISERROR('Não é possível inserir valores nulos ou negativos.', 16, 1);
	ELSE IF (@select_row IS NULL)
		-- realização de um novo insert
		INSERT INTO [scReserva].[Reserva_Servico] (id_reserva, id_servico, num_solicitacao)
		VALUES 	(@id_reserva, @id_servico, @num_quantidade);
	ELSE
		-- realização da atualização do número de pedidos
		UPDATE [scReserva].[Reserva_Servico]
		SET num_solicitacao = (@select_row + @num_quantidade)
		WHERE id_reserva = @id_reserva AND id_servico = @id_servico
END
GO


--	procedure para a identificação de erros ocorridos em um TRY...CATCH
CREATE PROCEDURE [scSistema].[proc_select_Error]
AS
BEGIN
	SET NOCOUNT ON

	SELECT ERROR_NUMBER() AS ErrorNumber,
			ERROR_SEVERITY() AS ErrorSeverity,
			ERROR_STATE() AS ErrorState,
			ERROR_PROCEDURE() AS ErrorProcedure,
			ERROR_LINE() AS ErrorLine,
			ERROR_MESSAGE() AS ErrorMessage
END
GO


--	insere um novo email no [scPessoa].[Email]
CREATE PROCEDURE [scPessoa].[proc_insert_Email]
	@novo_email VARCHAR(80),
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_email VARCHAR(80); -- verifica se o email já está cadastrado

	SET @select_email = (SELECT email FROM [scPessoa].[Email]
							WHERE email = @novo_email)

	IF (@select_email) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de email
		RAISERROR('Email já cadastrado.', 16, 1);
	ELSE IF CHARINDEX(' ', @novo_email) > 0
		-- impede que emails com espaços sejam aceitos
		RAISERROR('Emails não podem conter espaços.', 16, 1);
	ELSE IF (@novo_email NOT LIKE '%[A-Za-z0-9][@][A-Za-z0-9]%[.][A-Za-z0-9]%')
		-- impede que emails fora do padrão sejam aceitos
		RAISERROR('Este email é inválido.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_email
				INSERT INTO [scPessoa].[Email] (email, observacao)
				VALUES (@novo_email, @observacao)

				
			COMMIT TRAN tran_insert_email
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_email

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END
GO


--	insere um novo telefone em [scPessoa].[Telefone]
CREATE PROCEDURE [scPessoa].[proc_insert_Telefone]
	@codigo_pais SMALLINT,
	@codigo_area SMALLINT,
	@novo_telefone INT,
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_telefone INT; -- verifica se o telefone já foi cadastrado antes
	
	SET	@select_telefone = (SELECT telefone FROM [scPessoa].[Telefone]
							WHERE codigo_pais = @codigo_pais AND codigo_area = @codigo_area AND telefone = @novo_telefone)
	
	IF (@select_telefone) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de telefone
		RAISERROR('Telefone já cadastrado.', 16, 1);
	ELSE IF LEN(@novo_telefone) < 4
		-- levanta um erro no caso de um número de telefone muito pequeno
		RAISERROR('Número de telefone muito curto.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_telefone
				INSERT INTO [scPessoa].[Telefone] (codigo_pais, codigo_area, telefone, observacao)
				VALUES (@codigo_pais, @codigo_area, @novo_telefone, @observacao)

			COMMIT TRAN tran_insert_telefone
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_telefone

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY()
END
GO


--	insere novos endereços em [scPessoa].[Endereco]
CREATE PROCEDURE [scPessoa].[proc_inserir_Endereco]
	@pais VARCHAR(60),
	@estado VARCHAR(60),
	@cidade VARCHAR(60),
	@bairro VARCHAR(60),
	@rua VARCHAR(60),
	@numero INT,
	@complemento VARCHAR(20),
	@cep INT,
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	SET @retornar_id = (SELECT TOP 1 id_endereco FROM [scPessoa].[Endereco]
						WHERE pais = @pais AND estado = @estado AND cidade = @cidade AND bairro = @bairro AND 
								rua = @rua AND numero = @numero AND cep = @cep)
	
	IF (@retornar_id IS NOT NULL)
		-- caso o endereço já esteja cadastrado, apenas retorna o id dele
		RETURN
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_endereco
				INSERT INTO [scPessoa].[Endereco] (pais, estado, cidade, bairro, rua, numero, complemento, cep, observacao)
				VALUES (@pais, @estado, @cidade, @bairro, @rua, @numero, @complemento, @cep, @observacao)

			COMMIT TRAN tran_insert_endereco
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_endereco

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY()
END


--	insere um novo deposito bancário em [scFuncionario].[Deposito_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_insert_DepositoFuncionario]
	@numero_conta INT,
	@codigo_agencia SMALLINT,
	@tipo_conta TINYINT,
	@nome_banco VARCHAR(30),
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_deposito SMALLINT

	SET @select_deposito = (SELECT id_deposito FROM [scFuncionario].[Deposito_Funcionario]
							WHERE numero_conta = @numero_conta AND codigo_agencia = @codigo_agencia)

	IF (@select_deposito) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de conta depósito
		RAISERROR('Conta de depósito já cadastrado.', 16, 1);
	ELSE IF LEN(@codigo_agencia) NOT BETWEEN 3 AND 4
		-- levanta um erro para códigos de agência inválidos
		RAISERROR('Conta de agência é inválido.', 16, 1);
	ELSE IF LEN(@numero_conta) NOT BETWEEN 3 AND 14
		-- levanta um erro para números de conta inválidos
		RAISERROR('Número de conta inválido.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_deposito
				INSERT INTO [scFuncionario].[Deposito_Funcionario] (numero_conta, codigo_agencia, tipo_conta, nome_banco)
				VALUES (@numero_conta, @codigo_agencia, @tipo_conta, @nome_banco)

			COMMIT TRAN tran_insert_deposito
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_deposito

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END


--	cria um novo contrato de funcionário em [scFuncionario].[Contrato_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_insert_ContratoFuncionario]
	@id_funcionario SMALLINT,
	@dt_admissao DATE
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_funcionario SMALLINT

	SET @select_funcionario = (SELECT id_funcionario FROM [scFuncionario].[Contrato_Funcionario]
								WHERE id_funcionario = @id_funcionario)
	
	IF (@select_funcionario) IS NOT NULL
		-- levanta um erro caso o funcionário já esteja cadastrado
		RAISERROR('Funcionário já cadastrado.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_contrato
				INSERT INTO [scFuncionario].[Contrato_Funcionario] (id_funcionario, dt_admissao)
				VALUES (@id_funcionario, @dt_admissao)

			COMMIT TRAN tran_insert_contrato
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_contrato

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END


--	cria uma nova conta para o funcionario em [scFuncionario].[Conta_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_create_ContaFuncionario]
	@nome_funcionario VARCHAR(20),
	@sobrenome_funcionario VARCHAR(80),
	@cpf_funcionario BIGINT,
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @create_conta VARCHAR(25)

	SET @create_conta = CONCAT(SUBSTRING(@nome_funcionario, 1, 5),
								'.',
								SUBSTRING(@sobrenome_funcionario, 1, 5),
								SUBSTRING(CAST(@cpf_funcionario AS VARCHAR(11)), 1, 2),
								SUBSTRING(CAST(@cpf_funcionario AS VARCHAR(11)), 8, 3))

	BEGIN TRY
		BEGIN TRAN tran_create_conta
			INSERT INTO [scFuncionario].[Conta_Funcionario] (usuario, senha)
			VALUES (@create_conta, '12341234')

		COMMIT TRAN tran_create_conta
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN tran_create_conta

		EXEC [scSistema].[proc_select_Error]

		RETURN
	END CATCH

	SET @retornar_id = SCOPE_IDENTITY();
END
GO


--	insere um novo funcionario em [scFuncionario].[Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_inserir_Funcionario]
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@novo_email INT,
	@novo_telefone INT,
	@contato_emergencia INT,
	@novo_endereco INT,
	@id_funcao TINYINT,
	@novo_deposito SMALLINT,
	@observacao VARCHAR(255),
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_cpf BIGINT, @select_email INT, @select_telefone INT, @select_deposito SMALLINT, @create_conta SMALLINT -- verificam se essas informações já foram inseridas

	SET @select_cpf = (SELECT cpf FROM [scFuncionario].[Funcionario] WHERE cpf = @novo_cpf)
	SET @select_email = (SELECT id_email FROM [scFuncionario].[Funcionario] WHERE id_email = @novo_email)
	SET @select_telefone = (SELECT id_telefone FROM [scFuncionario].[Funcionario] WHERE id_telefone = @novo_telefone)
	SET @select_deposito = (SELECT id_deposito FROM [scFuncionario].[Funcionario] WHERE id_deposito = @novo_deposito)

	IF (@select_cpf) IS NOT NULL
		-- levanta um erro caso o cpf já esteja cadastrado
		RAISERROR('Cpf já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_email) IS NOT NULL
		-- levanta um erro caso o id_email já esteja cadastrado
		RAISERROR('Email já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_telefone) IS NOT NULL
		-- levanta um erro caso o id_telefone já esteja cadastrado
		RAISERROR('Telefone já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_deposito) IS NOT NULL
		-- levanta um erro caso o id_deposito já esteja cadastrado
		RAISERROR('Deposito já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (DATEDIFF(YEAR, @novo_dt_nascimento, GETDATE())) < 14
		-- levanta um erro caso a pessoa não tenha idade mínima para trabalhar na empresa
		RAISERROR('A pessoa é jovem de mais para ser funcionária da empresa.', 16, 1);

	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);

	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_funcionario
				IF (@id_funcao NOT IN (16, 20, 21, 22, 24))
					EXEC [scFuncionario].[proc_create_ContaFuncionario] @novo_nome, @novo_sobrenome, @novo_cpf, @create_conta OUTPUT
				ELSE
					SET @create_conta = NULL

				INSERT INTO [scFuncionario].[Funcionario] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, id_email, id_telefone,
															contato_emergencia, id_endereco, id_funcao, id_deposito, id_conta, status, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @novo_email, @novo_telefone,
						@contato_emergencia, @novo_endereco, @id_funcao, @novo_deposito, @create_conta, 1, @observacao)

			COMMIT TRAN tran_insert_funcionario
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_funcionario

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END


--	insere um novo hóspede em [scHospede].[Hospede] e informa sua categoria em [scHospede].[Hospede_Classe]
CREATE PROCEDURE [scHospede].[proc_insert_HospedePrincipal]
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@novo_email INT,
	@novo_telefone INT,
	@novo_endereco INT,
	@id_td_hospede TINYINT,
	@observacao VARCHAR(255),
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_cpf BIGINT, @select_email INT, @select_telefone INT, @select_tp_hospede TINYINT

	SET @select_cpf = (SELECT cpf FROM [scHospede].[Hospede] WHERE cpf = @novo_cpf)
	SET @select_email = (SELECT id_email FROM [scHospede].[Hospede] WHERE id_email = @novo_email)
	SET @select_telefone = (SELECT id_telefone FROM [scHospede].[Hospede] WHERE id_telefone = @novo_telefone)
	SET @select_tp_hospede = (SELECT id_tp_hospede FROM [scHospede].[Tipo_Hospede] WHERE id_tp_hospede = @id_td_hospede)

	IF (@select_cpf) IS NOT NULL
		-- levanta um erro caso o cpf já esteja cadastrado
		RAISERROR('Cpf já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_email) IS NOT NULL
		-- levanta um erro caso o id_email já esteja cadastrado
		RAISERROR('Email já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_telefone) IS NOT NULL
		-- levanta um erro caso o id_telefone já esteja cadastrado
		RAISERROR('Telefone já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_tp_hospede) IS NULL
		-- levanta um erro caso o tipo_hospede seja inválido
		RAISERROR('A categoria informada é inválida.', 16, 1);
	ELSE IF (DATEDIFF(YEAR, @novo_dt_nascimento, GETDATE())) < 18
		-- levanta um erro caso o hóspede não seja de maior
		RAISERROR('Não é permitido que menores de idade se hospedem.', 16, 1);
	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);
	ELSE IF @novo_nome IS NULL OR
			@novo_sobrenome IS NULL OR
			@novo_dt_nascimento IS NULL OR
			@novo_cpf IS NULL OR
			@novo_rg IS NULL OR
			@novo_sexo IS NULL OR
			@novo_email IS NULL OR
			@novo_telefone IS NULL OR
			@novo_endereco IS NULL OR
			@id_td_hospede IS NULL
		-- levanta um erro caso algum desses parâmetros seja NULL
		RAISERROR('Todas as informações são obrigatórias.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_hospede
				INSERT INTO [scHospede].[Hospede] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, id_email, id_telefone, id_endereco, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @novo_email, @novo_telefone, @novo_endereco, @observacao)

				SET @retornar_id = SCOPE_IDENTITY()

				INSERT INTO [scHospede].[Hospede_Classe] (id_hospede, id_tp_hospede)
				VALUES (@retornar_id, @id_td_hospede)

			COMMIT TRAN tran_insert_hospede
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_hospede

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END


--	inserir hóspedes dependentes em [scHospede].[Hospede]
CREATE PROCEDURE [scHospede].[proc_insert_HospedeDependente]
	@id_responsavel INT,
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@observacao VARCHAR(255),
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_responsavel INT

	SET @select_responsavel = (SELECT id_hospede FROM [scHospede].[Hospede] WHERE (id_hospede = @id_responsavel) AND 
																					(responsavel IS NULL) AND 
																					(cpf IS NOT NULL) AND 
																					(id_email IS NOT NULL) AND 
																					(id_telefone IS NOT NULL) AND 
																					(id_endereco IS NOT NULL))

	IF (@select_responsavel) IS NULL
		-- levanta um erro caso o hóspede não exista
		RAISERROR('O hóspede não existe ou não possue todos os dados obrigatórios.', 16, 1);
	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_dependente

				INSERT INTO [scHospede].[Hospede] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, responsavel, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @id_responsavel, @observacao)

			COMMIT TRAN tran_insert_dependente

			SET @retornar_id = SCOPE_IDENTITY()
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_dependente

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO


--	insere um novo serviço em [scEstalagem].[Servico]
CREATE PROCEDURE [scEstalagem].[proc_insert_Servico]
	@novo_servico VARCHAR(20),
	@valor_servico DECIMAL(5, 2)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_servico VARCHAR(20)

	SET @select_servico = (SELECT id_servico FROM [scEstalagem].[Servico] WHERE LOWER(descricao) = LOWER(@novo_servico))

	IF (@select_servico) IS NOT NULL
		-- levanta um erro no caso de uma duplicidade de serviços
		RAISERROR('O serviço já consta na base de dados.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_servico

				INSERT INTO [scEstalagem].[Servico] (descricao, valor)
				VALUES (@novo_servico, @valor_servico)

			COMMIT TRAN tran_insert_servico
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_servico

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO


--	insere um novo serviço em [scEstalagem].[Cardapio_Bar]
CREATE PROCEDURE [scEstalagem].[proc_insert_ProdutoCardapio]
	@novo_produto VARCHAR(20),
	@valor_servico DECIMAL(5, 2)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_produto VARCHAR(20)

	SET @select_produto = (SELECT id_produto FROM [scEstalagem].[Cardapio_Bar] WHERE LOWER(descricao) = LOWER(@novo_produto))

	IF (@select_produto) IS NOT NULL
		-- levanta um erro no caso de uma duplicidade de produtos
		RAISERROR('O produto já consta no cardápio.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_produto

				INSERT INTO [scEstalagem].[Cardapio_Bar] (descricao, valor)
				VALUES (@novo_produto, @valor_servico)

			COMMIT TRAN tran_insert_produto
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_produto

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO


--	insere tanto o hóspede principal quanto os dependentes na associativa [scReserva].[Estadia]
CREATE PROCEDURE [scReserva].[proc_insert_Estadia]
	@id_reserva INT,
	@id_hospede INT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT, @select_reserva INT, @select_hospede INT

	SET @select_row = (SELECT id_reserva FROM [scReserva].[Estadia] WHERE (id_reserva = @id_reserva) AND (id_hospede = @id_hospede))
	SET @select_reserva = (SELECT id_reserva FROM [scReserva].[Reserva] WHERE (id_reserva = @id_reserva) AND (status = 1))
	SET @select_hospede = (SELECT id_hospede FROM [scHospede].[Hospede] WHERE (id_hospede = @id_hospede) AND (hospede_retido IS NULL))

	IF (@select_reserva) IS NULL
		-- em caso da reserva não existir ou estar encerrada
		RAISERROR('Reserva não existe ou está encerrada.', 16, 1)
	ELSE IF (@select_hospede) IS NULL
		-- em caso do hóspede não existir ou estar impedido de se hospedar
		RAISERROR('Hospede não existe ou está restrito.', 16, 1)
	ELSE IF (@select_row) IS NOT NULL
		-- levanta erro caso o hóspede já esteja cadastrado nesta reserva
		RAISERROR('Hospede já cadastrado.', 16, 1)
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_estadia

				INSERT INTO [scReserva].[Estadia] (id_reserva, id_hospede)
				VALUES (@id_reserva, @id_hospede)

			COMMIT TRAN tran_insert_estadia
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_estadia

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO


--	insere as avaliações feitas pelos clientes em [scReserva].[Avaliacao]
CREATE PROCEDURE [scReserva].[proc_insert_Avaliacao]
	@id_reserva INT,
	@id_tp_contato TINYINT,
	@novo_conforto DECIMAL(5, 2),
	@novo_custo_benef DECIMAL(5, 2),
	@novo_funcionario DECIMAL(5, 2),
	@novo_localizacao DECIMAL(5, 2),
	@novo_limpeza DECIMAL(5, 2)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT, -- seleciona a linha que possuem os mesmos id_reserva e id_contato
			@select_reserva INT, @select_tp_contato INT -- verifica se eles existem

	SET @select_row = (SELECT id_reserva FROM [scReserva].[Avaliacao] WHERE (id_reserva = @id_reserva) AND (id_contato = @id_tp_contato))
	SET @select_reserva = (SELECT id_reserva FROM [scReserva].[Reserva] WHERE id_reserva = @id_reserva)
	SET @select_tp_contato = (SELECT id_tp_contato FROM [scReserva].[Tipo_Contato] WHERE id_tp_contato = @id_tp_contato)

	IF (@select_row) IS NOT NULL
		-- impede avaliações duplicadas
		RAISERROR('Avaliação já registrada.', 16, 1)
	ELSE IF (@select_tp_contato) IS NULL
		-- em caso do formato de contato não exista
		RAISERROR('Forma de contato não válido.', 16, 1)
	ELSE IF (@select_reserva) IS NULL
		-- em caso da reserva não existir
		RAISERROR('Reserva não existe.', 16, 1)
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_avaliacao

				INSERT INTO [scReserva].[Avaliacao] (id_contato, id_reserva, conforto, custo_beneficio, funcionarios, localizacao, limpeza)
				VALUES (@id_tp_contato, @id_reserva, @novo_conforto, @novo_custo_benef, @novo_funcionario, @novo_localizacao, @novo_limpeza)

			COMMIT TRAN tran_insert_avaliacao
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_avaliacao

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO


--	inserir pedidos de produtos na associativa [scReserva].[Reserva_Despesa]
CREATE PROCEDURE [scReserva].[proc_insert_ReservaDespesa]
	@id_reserva INT,
	@novo_despesa VARCHAR(255),
	@novo_valor DECIMAL(5, 2)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT, -- verifica se a despesa já foi arquivada
			@select_reserva INT

	SET @select_row = (SELECT id_despesa FROM [scReserva].[Reserva_Despesa] WHERE (id_reserva = @id_reserva) AND (LOWER(despesa) = LOWER(@novo_despesa)));
	SET @select_reserva = (SELECT id_reserva FROM [scReserva].[Reserva] WHERE id_reserva = @id_reserva);

	IF (@select_row IS NOT NULL)
		-- evita a duplicidade de despesas
		RAISERROR('A despesa já foi registrada no sistema.', 16, 1);
	ELSE IF (@select_reserva IS NULL)
		-- em caso da reserva não existir
		RAISERROR('Reserva inexistente.', 16, 1);
	ELSE IF (@novo_valor <= 0)
		-- impede a inserção de valores negativos e nulos
		RAISERROR('Não é possível inserir valores nulos ou negativos.', 16, 1);
	ELSE 
		-- realização de um novo insert
		INSERT INTO [scReserva].[Reserva_Despesa] (id_reserva, despesa, valor)
		VALUES 	(@id_reserva, @novo_despesa, @novo_valor);
END
GO


--	insere uma nova reserva em [scReserva].[Reserva]
CREATE PROCEDURE [scReserva].[proc_insert_Reserva]
	@novo_dt_checkin DATETIME,
	@id_funcion_checkin SMALLINT,
	@id_hospede INT,
	@num_hospede TINYINT,
	@id_quarto TINYINT,
	@id_contato TINYINT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT, @select_funcionario TINYINT, @select_hospede INT, @select_quarto TINYINT, @select_contato TINYINT

	SET @select_row = (SELECT id_reserva FROM [scReserva].[Reserva] WHERE (hospede_principal = @id_hospede) AND (data_checkin = @novo_dt_checkin) AND (id_quarto = @id_quarto))
	SET @select_funcionario = (SELECT id_funcao FROM [scFuncionario].[Funcionario] WHERE id_funcionario = @id_funcion_checkin)
	SET @select_hospede = (SELECT hospede_retido FROM [scHospede].[Hospede] WHERE id_hospede = @id_hospede)
	SET @select_quarto = (SELECT status FROM [scEstalagem].[Quarto] WHERE id_quarto = @id_quarto)
	SET @select_contato = (SELECT id_tp_contato FROM [scReserva].[Tipo_Contato] WHERE id_tp_contato = @id_contato)
	
	IF (@select_row IS NOT NULL)
		-- em caso da reserva já ter sido feita
		RAISERROR('A reserva já foi realizada.', 16, 1)
	ELSE IF (@select_funcionario IS NULL)
		-- em caso de um funcionário não existir
		RAISERROR('O funcionário não existe.', 16, 1)
	ELSE IF (@select_funcionario NOT IN (1, 13, 14))
		-- em caso de um funcionário não altorizado tentar fazer a reserva
		RAISERROR('O funcionário não possui altorização para fazer o cadastro.', 16, 1)
	ELSE IF (@select_hospede IS NULL)
		-- caso o hóspede não exista
		RAISERROR('O hóspede não existe.', 16, 1)
	ELSE IF (@select_hospede = 1)
		-- caso o hóspede esteja proibido de se hospedar
		RAISERROR('O hóspede está retido e não pode se instalar no Resort.', 16, 1)
	ELSE IF (@num_hospede < 1)
		-- caso não haja pelo menos 1 hóspede
		RAISERROR('Uma reserva deve conter pelo menos 1 hóspede.', 16, 1)
	ELSE IF (@select_quarto IS NULL)
		-- caso o quarto não exista
		RAISERROR('O quarto não existe.', 16, 1)
	ELSE IF (@select_quarto = 1)
		-- caso o quarto esteja ocupado
		RAISERROR('O quarto já está reservado.', 16, 1)
	ELSE IF (@select_contato IS NULL)
		-- caso o formato de contato não exista
		RAISERROR('O tipo de contato não existe.', 16, 1)
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_reserva

				INSERT INTO [scReserva].[Reserva] (data_checkin, funcion_checkin, hospede_principal, num_hospede, id_quarto, id_contato, status)
				VALUES (@novo_dt_checkin, @id_funcion_checkin, @id_hospede, @num_hospede, @id_quarto, @id_contato, 1)

				UPDATE [scEstalagem].[Quarto]
				SET status = 1
				WHERE id_quarto = @id_quarto

			COMMIT TRAN tran_insert_reserva
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_reserva

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO

