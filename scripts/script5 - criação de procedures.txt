--	inserir pedidos de produtos na associativa [Reserva_Bar]
CREATE PROCEDURE [scReserva].[proc_insert_ReservaBar]
	@id_reserva INT,
	@id_produto TINYINT,
	@num_quantidade TINYINT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT; -- verifica se a reserva já consumiu o produto antes, selecionando o número de pedidos registrados
	DECLARE @select_reserva INT; -- verifica se a reserva existe, selecionando o status atual da reserva
	DECLARE @select_produto TINYINT; -- verifica se o produto existe

	SET @select_row = (SELECT num_pedidos FROM [scReserva].[Reserva_Bar] 
						WHERE id_reserva = @id_reserva AND id_produto = @id_produto);

	SET @select_reserva = (SELECT status FROM [scReserva].[Reserva]
							WHERE id_reserva = @id_reserva);

	SET @select_produto = (SELECT id_produto FROM [scEstalagem].[Cardapio_Bar]
							WHERE id_produto = @id_produto);

	IF (@select_reserva = 0)
		-- em caso da reserva já estar encerrada
		RAISERROR('A reserva já foi encerrada.', 16, 1)
	ELSE IF (@select_reserva IS NULL)
		-- em caso de um id_reserva não existente
		RAISERROR('Reserva inexistente.', 16, 1);
	ELSE IF (@select_produto IS NULL)
		-- em caso de um id_produto não existente
		RAISERROR('Produto não consta no banco.', 16, 1);
	ELSE IF (@num_quantidade < 1)
		-- impede a inserção de´valores negativos e nulos
		RAISERROR('Não é possível inserir valores nulos ou negativos.', 16, 1);
	ELSE IF (@select_row IS NULL)
		-- realização de um novo insert
		INSERT INTO [scReserva].[Reserva_Bar] (id_reserva, id_produto, num_pedidos)
		VALUES 	(@id_reserva, @id_produto, @num_quantidade);
	ELSE
		-- realização da atualização do número de pedidos
		UPDATE [scReserva].[Reserva_Bar]
		SET num_pedidos = (@select_row + @num_quantidade)
		WHERE id_reserva = @id_reserva AND id_produto = @id_produto
END
GO


--	inserir pedidos de servicos na associativa [scReserva].[Reserva_Servico]
CREATE PROCEDURE [scReserva].[proc_insert_ReservaServico]
	@id_reserva INT,
	@id_servico TINYINT,
	@num_quantidade TINYINT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_row INT; -- verifica se a reserva já solicitou o serviço antes, selecionando o número de solicitações registradas
	DECLARE @select_reserva INT; -- verifica se a reserva existe, selecionando o status atual da reserva
	DECLARE @select_servico TINYINT; -- verifica se o serviço é oferecido

	SET @select_row = (SELECT num_solicitacao FROM [scReserva].[Reserva_Servico] 
						WHERE id_reserva = @id_reserva AND id_servico = @id_servico);

	SET @select_reserva = (SELECT status FROM [scReserva].[Reserva]
							WHERE id_reserva = @id_reserva);

	SET @select_servico = (SELECT id_servico FROM [scEstalagem].[Servico]
							WHERE id_servico = @id_servico);

	IF (@select_reserva = 0)
		-- em caso da reserva já estar encerrada
		RAISERROR('A reserva já foi encerrada.', 16, 1)
	ELSE IF (@select_reserva IS NULL)
		-- em caso de um id_reserva não existente
		RAISERROR('Reserva inexistente.', 16, 1);
	ELSE IF (@select_servico IS NULL)
		-- em caso de um id_servico não existente
		RAISERROR('Serviço não consta no banco.', 16, 1);
	ELSE IF (@num_quantidade < 1)
		-- impede a inserção de´valores negativos e nulos
		RAISERROR('Não é possível inserir valores nulos ou negativos.', 16, 1);
	ELSE IF (@select_row IS NULL)
		-- realização de um novo insert
		INSERT INTO [scReserva].[Reserva_Servico] (id_reserva, id_servico, num_solicitacao)
		VALUES 	(@id_reserva, @id_servico, @num_quantidade);
	ELSE
		-- realização da atualização do número de pedidos
		UPDATE [scReserva].[Reserva_Servico]
		SET num_solicitacao = (@select_row + @num_quantidade)
		WHERE id_reserva = @id_reserva AND id_servico = @id_servico
END
GO


--	procedure para a identificação de erros ocorridos em um TRY...CATCH
CREATE PROCEDURE [scSistema].[proc_select_Error]
AS
BEGIN
	SET NOCOUNT ON

	SELECT ERROR_NUMBER() AS ErrorNumber,
			ERROR_SEVERITY() AS ErrorSeverity,
			ERROR_STATE() AS ErrorState,
			ERROR_PROCEDURE() AS ErrorProcedure,
			ERROR_LINE() AS ErrorLine,
			ERROR_MESSAGE() AS ErrorMessage
END
GO


--	insere um novo email no [scPessoa].[Email]
CREATE PROCEDURE [scPessoa].[proc_insert_Email]
	@novo_email VARCHAR(80),
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_email VARCHAR(80); -- verifica se o email já está cadastrado

	SET @select_email = (SELECT email FROM [scPessoa].[Email]
							WHERE email = @novo_email)

	IF (@select_email) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de email
		RAISERROR('Email já cadastrado.', 16, 1);
	ELSE IF CHARINDEX(' ', @novo_email) > 0
		-- impede que emails com espaços sejam aceitos
		RAISERROR('Emails não podem conter espaços.', 16, 1);
	ELSE IF (@novo_email NOT LIKE '%[A-Za-z0-9][@][A-Za-z0-9]%[.][A-Za-z0-9]%')
		-- impede que emails fora do padrão sejam aceitos
		RAISERROR('Este email é inválido.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_email
				INSERT INTO [scPessoa].[Email] (email, observacao)
				VALUES (@novo_email, @observacao)

				
			COMMIT TRAN tran_insert_email
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_email

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END
GO


--	insere um novo telefone em [scPessoa].[Telefone]
CREATE PROCEDURE [scPessoa].[proc_insert_Telefone]
	@codigo_pais SMALLINT,
	@codigo_area SMALLINT,
	@novo_telefone INT,
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_telefone INT; -- verifica se o telefone já foi cadastrado antes
	
	SET	@select_telefone = (SELECT telefone FROM [scPessoa].[Telefone]
							WHERE codigo_pais = @codigo_pais AND codigo_area = @codigo_area AND telefone = @novo_telefone)
	
	IF (@select_telefone) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de telefone
		RAISERROR('Telefone já cadastrado.', 16, 1);
	ELSE IF LEN(@novo_telefone) < 4
		-- levanta um erro no caso de um número de telefone muito pequeno
		RAISERROR('Número de telefone muito curto.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_telefone
				INSERT INTO [scPessoa].[Telefone] (codigo_pais, codigo_area, telefone, observacao)
				VALUES (@codigo_pais, @codigo_area, @novo_telefone, @observacao)

			COMMIT TRAN tran_insert_telefone
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_telefone

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY()
END
GO


--	insere novos endereços em [scPessoa].[Endereco]
CREATE PROCEDURE [scPessoa].[proc_inserir_Endereco]
	@pais VARCHAR(60),
	@estado VARCHAR(60),
	@cidade VARCHAR(60),
	@bairro VARCHAR(60),
	@rua VARCHAR(60),
	@numero INT,
	@complemento VARCHAR(20),
	@cep INT,
	@observacao VARCHAR(150) = NULL,
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	SET @retornar_id = (SELECT TOP 1 id_endereco FROM [scPessoa].[Endereco]
						WHERE pais = @pais AND estado = @estado AND cidade = @cidade AND bairro = @bairro AND 
								rua = @rua AND numero = @numero AND cep = @cep)
	
	IF (@retornar_id IS NOT NULL)
		-- caso o endereço já esteja cadastrado, apenas retorna o id dele
		RETURN
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_endereco
				INSERT INTO [scPessoa].[Endereco] (pais, estado, cidade, bairro, rua, numero, complemento, cep, observacao)
				VALUES (@pais, @estado, @cidade, @bairro, @rua, @numero, @complemento, @cep, @observacao)

			COMMIT TRAN tran_insert_endereco
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_endereco

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY()
END


--	insere um novo deposito bancário em [scFuncionario].[Deposito_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_insert_DepositoFuncionario]
	@numero_conta INT,
	@codigo_agencia SMALLINT,
	@tipo_conta TINYINT,
	@nome_banco VARCHAR(30),
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_deposito SMALLINT

	SET @select_deposito = (SELECT id_deposito FROM [scFuncionario].[Deposito_Funcionario]
							WHERE numero_conta = @numero_conta AND codigo_agencia = @codigo_agencia)

	IF (@select_deposito) IS NOT NULL
		-- levanta um erro no caso de uma duplicata de conta depósito
		RAISERROR('Conta de depósito já cadastrado.', 16, 1);
	ELSE IF LEN(@codigo_agencia) NOT BETWEEN 3 AND 4
		-- levanta um erro para códigos de agência inválidos
		RAISERROR('Conta de agência é inválido.', 16, 1);
	ELSE IF LEN(@numero_conta) NOT BETWEEN 3 AND 14
		-- levanta um erro para números de conta inválidos
		RAISERROR('Número de conta inválido.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_deposito
				INSERT INTO [scFuncionario].[Deposito_Funcionario] (numero_conta, codigo_agencia, tipo_conta, nome_banco)
				VALUES (@numero_conta, @codigo_agencia, @tipo_conta, @nome_banco)

			COMMIT TRAN tran_insert_deposito
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_deposito

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END


--	cria um novo contrato de funcionário em [scFuncionario].[Contrato_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_insert_ContratoFuncionario]
	@id_funcionario SMALLINT,
	@dt_admissao DATE
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_funcionario SMALLINT

	SET @select_funcionario = (SELECT id_funcionario FROM [scFuncionario].[Contrato_Funcionario]
								WHERE id_funcionario = @id_funcionario)
	
	IF (@select_funcionario) IS NOT NULL
		-- levanta um erro caso o funcionário já esteja cadastrado
		RAISERROR('Funcionário já cadastrado.', 16, 1);
	ELSE
		-- realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_contrato
				INSERT INTO [scFuncionario].[Contrato_Funcionario] (id_funcionario, dt_admissao)
				VALUES (@id_funcionario, @dt_admissao)

			COMMIT TRAN tran_insert_contrato
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_contrato

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END


--	cria uma nova conta para o funcionario em [scFuncionario].[Conta_Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_create_ContaFuncionario]
	@nome_funcionario VARCHAR(20),
	@sobrenome_funcionario VARCHAR(80),
	@cpf_funcionario BIGINT,
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @create_conta VARCHAR(25)

	SET @create_conta = CONCAT(SUBSTRING(@nome_funcionario, 1, 5),
								'.',
								SUBSTRING(@sobrenome_funcionario, 1, 5),
								SUBSTRING(CAST(@cpf_funcionario AS VARCHAR(11)), 1, 2),
								SUBSTRING(CAST(@cpf_funcionario AS VARCHAR(11)), 8, 3))

	BEGIN TRY
		BEGIN TRAN tran_create_conta
			INSERT INTO [scFuncionario].[Conta_Funcionario] (usuario, senha)
			VALUES (@create_conta, '12341234')

		COMMIT TRAN tran_create_conta
	END TRY
	BEGIN CATCH
		ROLLBACK TRAN tran_create_conta

		EXEC [scSistema].[proc_select_Error]

		RETURN
	END CATCH

	SET @retornar_id = SCOPE_IDENTITY();
END
GO


--	insere um novo funcionario em [scFuncionario].[Funcionario]
CREATE PROCEDURE [scFuncionario].[proc_inserir_Funcionario]
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@novo_email INT,
	@novo_telefone INT,
	@contato_emergencia INT,
	@novo_endereco INT,
	@id_funcao TINYINT,
	@novo_deposito SMALLINT,
	@observacao VARCHAR(255),
	@retornar_id SMALLINT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_cpf BIGINT, @select_email INT, @select_telefone INT, @select_deposito SMALLINT, @create_conta SMALLINT -- verificam se essas informações já foram inseridas

	SET @select_cpf = (SELECT cpf FROM [scFuncionario].[Funcionario] WHERE cpf = @novo_cpf)
	SET @select_email = (SELECT id_email FROM [scFuncionario].[Funcionario] WHERE id_email = @novo_email)
	SET @select_telefone = (SELECT id_telefone FROM [scFuncionario].[Funcionario] WHERE id_telefone = @novo_telefone)
	SET @select_deposito = (SELECT id_deposito FROM [scFuncionario].[Funcionario] WHERE id_deposito = @novo_deposito)

	IF (@select_cpf) IS NOT NULL
		-- levanta um erro caso o cpf já esteja cadastrado
		RAISERROR('Cpf já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_email) IS NOT NULL
		-- levanta um erro caso o id_email já esteja cadastrado
		RAISERROR('Email já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_telefone) IS NOT NULL
		-- levanta um erro caso o id_telefone já esteja cadastrado
		RAISERROR('Telefone já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (@select_deposito) IS NOT NULL
		-- levanta um erro caso o id_deposito já esteja cadastrado
		RAISERROR('Deposito já cadastrado para outro funcionário.', 16, 1);

	ELSE IF (DATEDIFF(YEAR, @novo_dt_nascimento, GETDATE())) < 14
		-- levanta um erro caso a pessoa não tenha idade mínima para trabalhar na empresa
		RAISERROR('A pessoa é jovem de mais para ser funcionária da empresa.', 16, 1);

	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);

	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_funcionario
				IF (@id_funcao NOT IN (16, 20, 21, 22, 24))
					EXEC [scFuncionario].[proc_create_ContaFuncionario] @novo_nome, @novo_sobrenome, @novo_cpf, @create_conta OUTPUT
				ELSE
					SET @create_conta = NULL

				INSERT INTO [scFuncionario].[Funcionario] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, id_email, id_telefone,
															contato_emergencia, id_endereco, id_funcao, id_deposito, id_conta, status, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @novo_email, @novo_telefone,
						@contato_emergencia, @novo_endereco, @id_funcao, @novo_deposito, @create_conta, 1, @observacao)

			COMMIT TRAN tran_insert_funcionario
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_funcionario

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH

		SET @retornar_id = SCOPE_IDENTITY();
END


--	insere um novo hóspede em [scHospede].[Hospede] e informa sua categoria em [scHospede].[Hospede_Classe]
CREATE PROCEDURE [scHospede].[proc_insert_HospedePrincipal]
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@novo_email INT,
	@novo_telefone INT,
	@novo_endereco INT,
	@id_td_hospede TINYINT,
	@observacao VARCHAR(255),
	@retornar_id INT OUTPUT
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_cpf BIGINT, @select_email INT, @select_telefone INT, @select_tp_hospede TINYINT

	SET @select_cpf = (SELECT cpf FROM [scHospede].[Hospede] WHERE cpf = @novo_cpf)
	SET @select_email = (SELECT id_email FROM [scHospede].[Hospede] WHERE id_email = @novo_email)
	SET @select_telefone = (SELECT id_telefone FROM [scHospede].[Hospede] WHERE id_telefone = @novo_telefone)
	SET @select_tp_hospede = (SELECT id_tp_hospede FROM [scHospede].[Tipo_Hospede] WHERE id_tp_hospede = @id_td_hospede)

	IF (@select_cpf) IS NOT NULL
		-- levanta um erro caso o cpf já esteja cadastrado
		RAISERROR('Cpf já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_email) IS NOT NULL
		-- levanta um erro caso o id_email já esteja cadastrado
		RAISERROR('Email já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_telefone) IS NOT NULL
		-- levanta um erro caso o id_telefone já esteja cadastrado
		RAISERROR('Telefone já cadastrado para outro hóspede.', 16, 1);
	ELSE IF (@select_tp_hospede) IS NULL
		-- levanta um erro caso o tipo_hospede seja inválido
		RAISERROR('A categoria informada é inválida.', 16, 1);
	ELSE IF (DATEDIFF(YEAR, @novo_dt_nascimento, GETDATE())) < 18
		-- levanta um erro caso o hóspede não seja de maior
		RAISERROR('Não é permitido que menores de idade se hospedem.', 16, 1);
	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);
	ELSE IF @novo_nome IS NULL OR
			@novo_sobrenome IS NULL OR
			@novo_dt_nascimento IS NULL OR
			@novo_cpf IS NULL OR
			@novo_rg IS NULL OR
			@novo_sexo IS NULL OR
			@novo_email IS NULL OR
			@novo_telefone IS NULL OR
			@novo_endereco IS NULL OR
			@id_td_hospede IS NULL
		-- levanta um erro caso algum desses parâmetros seja NULL
		RAISERROR('Todas as informações são obrigatórias.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_hospede
				INSERT INTO [scHospede].[Hospede] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, id_email, id_telefone, id_endereco, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @novo_email, @novo_telefone, @novo_endereco, @observacao)

				SET @retornar_id = SCOPE_IDENTITY()

				INSERT INTO [scHospede].[Hospede_Classe] (id_hospede, id_tp_hospede)
				VALUES (@retornar_id, @id_td_hospede)

			COMMIT TRAN tran_insert_hospede
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_hospede

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END


--	inserir hóspedes dependentes em [scHospede].[Hospede]
CREATE PROCEDURE [scHospede].[proc_insert_HospedeDependente]
	@id_responsavel INT,
	@novo_nome VARCHAR(20),
	@novo_sobrenome VARCHAR(80),
	@novo_dt_nascimento DATE,
	@novo_cpf BIGINT,
	@novo_rg INT,
	@novo_sexo CHAR(1),
	@observacao VARCHAR(255)
AS
BEGIN
	SET NOCOUNT ON

	DECLARE @select_responsavel INT

	SET @select_responsavel = (SELECT id_hospede FROM [scHospede].[Hospede] WHERE (id_hospede = @id_responsavel) AND 
																					(responsavel IS NULL) AND 
																					(cpf IS NOT NULL) AND 
																					(id_email IS NOT NULL) AND 
																					(id_telefone IS NOT NULL) AND 
																					(id_endereco IS NOT NULL))

	IF (@select_responsavel) IS NULL
		-- levanta um erro caso o hóspede não exista
		RAISERROR('O hóspede não existe ou não possue todos os dados obrigatórios.', 16, 1);
	ELSE IF (LOWER(@novo_sexo) NOT IN ('m', 'f'))
		-- levanta um erro caso o sexo não seja masculino ou feminino
		RAISERROR('Sexo informado não é válido.', 16, 1);
	ELSE
		--	realiza um novo insert
		BEGIN TRY
			BEGIN TRAN tran_insert_dependente

				INSERT INTO [scHospede].[Hospede] (nome, sobrenome, dt_nascimento, cpf, rg, sexo, responsavel, observacao)
				VALUES (@novo_nome, @novo_sobrenome, @novo_dt_nascimento, @novo_cpf, @novo_rg, @novo_sexo, @id_responsavel, @observacao)

			COMMIT TRAN tran_insert_dependente
		END TRY
		BEGIN CATCH
			ROLLBACK TRAN tran_insert_dependente

			EXEC [scSistema].[proc_select_Error]

			RETURN
		END CATCH
END
GO
